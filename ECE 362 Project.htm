<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <link rel="icon" type="image/vnd.microsoft.icon" href="https://engineering.purdue.edu/favicon.ico"/>
    <link rel="stylesheet" type="text/css" href="https://engineering.purdue.edu/ece362/css/style.css"/>
    <title>ECE 362 Project</title>
    <style>
      /* Self-explanatory, and it looks nice */
      html {
      scroll-behavior: smooth;
      }

      /* AD2 vs ADALM2000 styling */
      .tbl {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      }
      .tbl tbody {
      width: 100%;
      }
      .tbl th {
      width: 10%;
      padding: 0.5% 2% 0.5% 2%;
      text-align: center;
      }
      .tbl th:not(:first-child) { /* recursive - applies to all children, not just one */
      width: 90%;
      border-left: 1px solid black;
      text-align: left;
      }
      .tbl > tbody > tr:not(:first-child) > th {
      font-weight: 200;
      }
      .tbl tr {
      width: 100%;
      border: 1px solid black;
      display: flex;
      }
      figcaption {
      text-align: center;
      }
      .lab_img {
      width: 100%;
      margin-top: 2%;
      }

      /* ToC styling */
      .toc {
      width: 100%;
      }
      .toc th {
      border: 1px solid black;
      padding: 0 1% 0 1%;
      }
      .toc > tbody > tr:first-child > th { 
      text-align: center;
      }
      .toc > tbody > tr:not(:first-child) > th { 
      font-weight: 200;
      }
      .toc > tbody > tr > th:first-child, .toc > tbody > tr > th:last-child {
      text-align: center;
      }
      .toc tbody {
      width: 100%;
      }
      .toc tr {
      width: max-content;
      }
      h2 {
      margin-top: 3%;
      }

      /* Checklist styling */
      .chklst {
      list-style: none;
      padding-left: 20px;
      }
      .chklst > li {
      display: flex;
      flex-direction: row;
      align-items: center;
      margin-bottom: 0.75%;
      }
      .spanbox {
      position: absolute;
      width: 25px;
      height: 25px;
      background-color: transparent;
      border-radius: 5px;
      transition: background-color 0.3s; 
      }
      .chkbox {
      width: 25px;
      height: 25px;
      padding: 0;
      margin: 0 10px 0 0;
      border-radius: 5px;
      display: block;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      }
      .chkbox .inputbox {
      position: absolute;
      opacity: 0;
      z-index: 2;
      width: 25px;
      height: 25px;
      }
      .chkbox .inputbox:checked ~ .spanbox {
      background-color: dimgray;
      }
      .attention {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 4vh 2vw 4vh 2vw;
      background: rgba(0,0,150,0.025);
      border: 1px solid rgba(100,100,255,1);
      border-radius: 5px;
      transition: background-color 0.3s;
      }
      .attention:hover {
      background: rgba(0,0,150,0.075);
      }
      .attention-row {
      display: flex;
      padding: 0 0 0 0;
      background: rgba(0,0,0,0);
      border: 0px;
      border-radius: 0px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>ECE 362 Lab Project: A small game</h1>
      <nav>
        <a href="https://engineering.purdue.edu/ece362/">Home</a>
        <a href="https://engineering.purdue.edu/ece362/about/">About</a>
        <a href="https://engineering.purdue.edu/ece362/refs/">References</a>
        <a href="https://engineering.purdue.edu/ece362/notes/">Notes</a>
        <a href="https://engineering.purdue.edu/ece362/hw/">Homework</a>
        <a href="https://engineering.purdue.edu/ece362/lab/">Labs</a>
      </nav>
    </header>
    <h2>Introduction</h2>

    <p>
      <a href="background.png">
        <img src="background.png" style="float: left; width: 15em; margin-right: 1em">
      </a>
      The open-ended team project in the last part of any normal
      semester is the best part of the course.  The experience of
      integrating variety of software components with different
      peripheral devices, and diagnosing their failures, is an
      excellent learning experience.  This time, we get only a small
      taste of that experience.
    </p>
    <p>
      One of the best ways to learn new techniques and practices
      skills with a microcontroller is to use it to build a game.
      Often, timing is important, so it forces you to think about
      resource limitations and alternatives.  The development process
      becomes the challenge to embrace.  You might become one of those
      people who enjoy developing the game more than actually playing
      it.
    </p>

    <h2>Instructional Objectives</h2>
    <ul>
      <li>
        To have some fun and get a little more experience.
      </li>
    </ul>
    <h2 id="toc">Table of Contents</h2>
    <table class="toc">
      <tr>
        <th>Step</th>
        <th>Description</th>
        <th>Points</th>
      </tr>
      <tr>
        <th>1</th>
        <th><a href="#Background">Background</a></th>
        <th></th>
      </tr>
      <tr>
        <th>1.1</th>
        <th><a href="#Standard">A Standard Game Platform</a></th>
        <th></th>
      </tr>
      <tr>
        <th>1.2</th>
        <th><a href="#Example">Example Games</a></th>
        <th></th>
      </tr>
      <tr>
        <th>1.3</th>
        <th><a href="#Image-Based">An Image-Based Game</a></th>
        <th></th>
      </tr>
      <tr>
        <th>1.4</th>
        <th><a href="#Drawn-Object">A Drawn Object Game</a></th>
        <th></th>
      </tr>
      <tr>
        <th>1.5</th>
        <th><a href="#Random">Seeding the Random Number Generator</a></th>
        <th></th>
      </tr>
      <tr>
        <th>1.6</th>
        <th><a href="#Music">Playing Music</a></th>
        <th></th>
      </tr>
      <tr>
        <th>1.7</th>
        <th><a href="#FAQ">Frequently Asked Questions</a></th>
        <th></th>
      </tr>
      <tr>
        <th>2</th>
        <th><a href="#Build">Build a Game</a></th>
        <th></th>
      </tr>
      <tr>
        <th>2.1</th>
        <th><a href="#Requirements">Requirements</th>
        <th></th>
      </tr>
      <tr>
        <th>2.2</th>
        <th><a href="#Weight">Grade Weight</a></th>
        <th></th>
      </tr>
      <tr>
        <th>2.3</th>
        <th><a href="#Scoring">Scoring</a></th>
        <th></th>
      </tr>
      <tr>
        <th>2.4</th>
        <th><a href="#Duedate">Due Date</a></th>
        <th></th>
      </tr>
      <tr>
        <th>3</th>
        <th><a href="#Submission">Submit your game files</a></th>
        <th>*</th>
      </tr>
      <tr>
        <th>&nbsp;</th>
        <th>Total: </th>
        <th></th>
      </tr>
    </table>
    <p>* All the points for this lab depend on proper completion of
    and submission of your files.</p>
    <a href='#Checklist'><p>When you are ready for your lab
    evaluation, review this checklist.</p></a>

    <h2 id="Background">Step 1: Background</h2>

    <h3 id="Standard">1.1 A Standard Game Platform</h3>

    <p>
      The course staff will need to evaluate the game you build, but
      they're not going to have time to rewire things.  Here, we define
      a standard hardware configuration that you should use:
      <ul>
        <li>
          The SOC1602A OLED LCD is wired to PB12, PB13, and PB15
          &mdash; just like it has been since lab 0.
        </li>
        <li>
          The 7-segment displays are wired to PC0 &ndash; PC10 as they
          were in lab 5.
        </li>
        <li>
          A potentiometer between 0V and 3.0V with a center tap connected
          to PA0, as it was for lab 6.
        </li>
        <li>
          The keypad matrix is wired to PB0 &ndash; PB7 as it was in
          lab 5.
        </li>
        <li>
          The RGB LED is wired to PA8 &ndash; PA10 as it was in lab 7.
        </li>
        <li>
          PA11 is connected to a low-pass filter as it was in lab 7.
          You may connect the capacitor to a powered speaker using the
          3.5 mm stereo jack in your lab kit.  You can use this for
          audio generation (since PA4 is used for NSS of SPI1).
        </li>
        <li>
          The MSP2202 TFT LCD is connected to PA2 &ndash PA5, and PA7
          as it was in lab 8.  Let's assume it's going to be used in
          "portrait" mode (240 pixels wide, and 320 pixels high).
        </li>
        <li>
          The 24AA32AF I2C EEPROM and MCP23008 I2C GPIO extender (and
          four LEDs) are connected as they were in lab 9.  (You may
          record a high score in the I2C EEPROM, but be sure to have a
          function to clear the EEPROM of information from put there
          by other students' games.)
        </li>
        <li>
          The USB-to-serial adapter is connected to PC12 and PD2 as it
          was in lab 10.
        </li>
        <li>
          You may not use the SD card interface for this game, so
          assume that PA1 is not connected to anything.
        </li>
      </ul>
    </p>

    <h3 id="Example">1.2 Example Games</h3>

    <p>
      There are as many styles of creating graphical games as there
      are hardware platforms.  It is helpful to have some examples to
      draw from to know what to do.  What follows are descriptions of
      two games that you may use parts from to make a new game.  (You
      may not simply turn in one of these two games.  You must make a
      different game.  Your game does not need to look like either of
      these games.)
    </p>

    <h3 id="Image-Based">1.3 An Image-Based Game</h3>

    <p>
      Look at the following files:
      <ul>
        <li>
          <a href="bounce.c">bounce.c</a> The majority of a
          ball-and-paddle game.  Just fill in
          the <b><code>setup_tim17()</code></b>,
          <b><code>setup_portb()</code></b>, <b><code>check_key()</code></b>,
          and <b><code>setup_spi1()</code></b> subroutines.
        </li>
        <li>
          <a href="background.c">background.c</a> A 240x320 background
          image.
          <br>And the <a href="gen-pic">Python program</a> used to
          generate it.
        </li>
        <li>
          <a href="ball.c">ball.c</a> A 19x19 purple ball with white
          corners.  This was created
          with <a href="https://www.gimp.org/">GIMP</a> and exported
          as a C file so that it can be compiled into the program.
        </li>
        <li>
          <a href="paddle.c">paddle.c</a> A 59x5 gold paddle rectangle.
        </li>
        <li>
          <a href="lcd.c">lcd.c</a> The graphical LCD driver program.
        </li>
        <li>
          <a href="lcd.h">lcd.h</a> The header file for the LCD driver.
        </li>
      </ul>
      This program implements a bouncing purple ball and a gold paddle
      that is moved left and right using the '*' and 'D' buttons on
      the keypad, respectively.  When the ball bounces off the walls
      or ceiling, the direction it goes is slightly randomized.  If
      the purple ball touches the bottom wall (instead of the paddle),
      the game ends.
    </p>

    <p>
      The entire background image is stored in Flash memory.  Since it
      is 240x320 (x 2 bytes per pixel), it occupies 153600 bytes.  This
      is acceptable since the STM32F091RCT6 has a Flash ROM capacity of
      262524 bytes.  The disadvantage is that the image must be sent
      over every time the chip is reprogrammed.  The programming step
      takes about 8 seconds.  Have patience.
    </p>

    <p>
      Since the entire background image is in Flash, it can be used
      and combined with other images to create smooth motion.  For
      instance, to move the 19x19 ball a few pixels in any direction:
      <ul>
        <li>
          The ball Picture is copied into the center of a 29x29
          "object" Picture that has white borders.  Now there is a
          purple 19x19 ball in a 29x29 square field of white (0xffff).
        </li>
        <li>
          A temporary image "tmp" of size 29x29 is created.
        </li>
        <li>
          A 29x29 section of the background image for the spot we want
          the ball to go is copied with
          the <b><code>pic_subset()</code></b> subroutine.
        </li>
        <li>
          The "object" Picture is copied over the 29x29 section of the
          "tmp" background section
          with <b><code>pic_overlay()</code></b>.  White is specified
          as a transparent color, so only the purple overlays the
          background image.
        </li>
        <li>
          For completeness, the paddle is also overlayed into the
          temporary image.  if the paddle is far away from the ball,
          nothing gets copied.
        </li>
        <li>
          The resulting image is drawn to the screen.  Since the
          background image will match what is already there, only
          the ball will appear to move.  Since there is a 5-pixel
          border around the ball, the ball may move up to 5 pixels
          in any direction and the new image will overwrite the old
          location of the ball.
        </li>
        <li>
          The smaller the size of the "object" and "tmp" Pictures,
          the faster they can be copied, overlayed, and drawn to
          the screen.  The larger the size of these Pictures, the
          greater the distance the ball can move between drawing
          steps.  With 29x29 Pictures, there is no problem having
          a 100 Hz refresh rate.  (Not bad at all.)
        </li>
      </ul>
    </p>

    <p>
      To handle the bounce, a heuristic is used to model the location
      of the ball.  If the ball is moving two or more pixels per step
      in the X direction, it may go past the left or right boundary.
      If it is calculated to be past the boundary, rather than drawing
      it past the boundary, the X component of its step velocity is
      reversed and that amount added to its X location.  For instance,
      if its X step velocity is 3 and it is one pixel from a boundary,
      the next step will exceed the boundary by 2.  The X step
      velocity is set to -3 and added to the X offset to produce a new
      location 1 pixel inside the boundary.  In one step, the ball
      would go from 1 pixel inside the boundary to 2 pixels inside the
      boundary (and headed in the opposite direction).
    </p>

    <p>
      It sounds sloppy, but looks quite realistic.
    </p>

    <p>
      This is not a very challenging game.  There are various things
      that can be done to increase the difficulty:
      <ul>
        <li>
          Gradually increase the interrupt rate.
        </li>
        <li>
          Increase the maximum component velocities.  Presently, the
          ball cannot travel more than two pixels per step in the X or
          Y directions.
        </li>
        <li>
          Make the paddle narrower.
        </li>
      </ul>
    </p>

    <h3 id="Drawn-Object">1.4 A Drawn Object Game</h3>

    <p>
      Look at the following files:
      <ul>
        <li>
          <a href="evileye.c">evileye.c</a> The game.
        </li>
        <li>
          <a href="lcd.c">lcd.c</a> The graphical LCD driver program.
        </li>
        <li>
          <a href="lcd.h">lcd.h</a> The header file for the LCD driver.
        </li>
      </ul>
      Fill in the
      <b><code>setup_tim17()</code></b>,
      <b><code>setup_portb()</code></b>,
      <b><code>wait_no_press()</code></b>,
      <b><code>get_press()</code></b>, and
      <b><code>setup_spi1()</code></b> subroutines and play the game.
    </p>

    <p>
      The Evil Eye game draws a maze with 3-D perspective.  You can
      navigate the maze by pressing '*' to turn to the left, '#' to
      turn to the right, and '8' to move forward.  At the same time,
      there is a floating eyeball moving throught the maze.  If the
      eyeball enters the same map square you occupy, the game is over.
    </p>

    <p>
      The map is represented by an array of <code>struct Room</code>
      that is nothing more than four integers the indicate the
      neighboring rooms to the north, west, south, and east.  The
      player and the eye each have a location variable that indicate
      what room they're in.  They also each have a direction variable to
      indicate which of the cardinal directions they're aimed in.
      Several subroutines help compute the next room in a direction or
      the "direction to the left of NORTH", etc.
    </p>

    <p>
      The main work of the application is the <b><code>view()</code></b>
      subroutine, which recursively displays the distance-adjusted
      persepective view of the straight line that the player is
      looking at.  For instance, if the player was looking ahead at
      a wall in a hallway that continued to the left and right,
      a picture would be drawn that looks like this:
      <pre>

        
        ____ ________________ ____
            |                |
            |                |
            |                |
            |                |
            |                |
            |                |
        ____|________________|____


        
      </pre>
      If it was a dead-end, it would draw this instead:
      <pre>
          \                    /
           \                  /
            \________________/
            |                |
            |                |
            |                |
            |                |
            |                |
            |                |
            |________________|
            /                \
           /                  \
          /                    \
      </pre>
      Here, the outer corners of the lines define an outer bounding
      box, and the rectangle in the middle defines an inner bounding
      box.  By scaling the outer bounding box to the inner bounding
      box, the hallway can be extended in the forward direction like
      so:
      <pre>
          \                    /
           \                  /
            \________________/
            |\              /|
            | \____________/ |
            |  |          |  |
            |  |          |  |
            |  |__________|  |
            | /            \ |
            |/______________\|
            /                \
           /                  \
          /                    \
      </pre>
      And the hallway could be extended by fitting the next stage of
      the hallway into the next smaller bounding box.  Connected
      adjacent cells are more clearly shown by omitting the lines on
      the floor and ceiling.  Left and right hallways are drawn by
      changing the diagonal lines to straight lines.  For instance,
      the following would be drawn for a map cell that is open
      straight ahead to another map cell that is open to the right:
      <pre>
          \                    /
           \                  /
            \                /
            |\               |
            | \______________|
            |  |          |  |
            |  |          |  |
            |  |__________|__|
            | /              |
            |/               |
            /                \
           /                  \
          /                    \
      </pre>
    </p>

    <p>
      The perspective view is computed by determining the distance
      of lines from a center point on the screen.  Each invocation
      of <code>view()</code> draws the lines for the region
      between the inner bounding box and outer bounding box.
      A "dist" argument keeps track of the distance from the
      player.  If the straight-ahead direction is reachable,
      the <code>view()</code> subroutine is invoked recursively
      with a "dist" argument that is one higher.
    </p>

    <p>
      For the sake of showing the view of someone standing
      in the middle of a map cell, the perspective is computed
      using <code>dist - 0.5</code> for the outer bounding box
      and <code>dist + 0.5</code> for the inner bounding box.
      The initial call has a <code>dist</code> of 0, so it is
      treated slightly differently.
    </p>
      
    <p>
      After the recursive invocation returns, the location of the
      floating eyebal is checked.  If the eyeball is in the map cell
      that is being drawn, it means it is in view of the player.  Its
      size is computed according to the perspective calculation.  The
      eye will always be in the center of the view.  Drawing the eye
      is complicated.  When the eye is looking at the player, the iris
      and pupil are simply concentric circles.  When the eye is looking
      left or right, those concentric circles must be drawn as chords.
      Fun.
    </p>
      
    <p>
      Since either the player or the the timer interrupt can initiate
      a call to <b><code>view()</code></b>, it is necessary to ensure
      that they don't end up doing so at the same time.  For instance,
      if the player presses a button, a call to <b><code>view()</code></b>
      happen immediately.  Since a deeply recursive call may take some
      time, the timer interrupt may happen in the middle.  This will
      move the eye and invoke a new call to <b><code>view()</code></b>,
      which will also be deeply recursive.  Rather than permitting this,
      the Timer 17 interrupt is disabled before a player update causes
      <b><code>view()</code></b> to be invoked.  The interrupt is re-enabled
      immediately after the call returns.
    </p>
      
    <p>
      This is a simple game to play.  The eyeball moves slowly and
      without a goal.  It moves forward until it cannot, and then it
      randomly turns left or right.  Since the random number generator
      is not <em>seeded</em>, the random sequence will be the same for
      every game.  Some things that would make the game better are:
      <ul>
        <li>
          The eye should chase after the player.  To do so, it would
          either need to "remember" which direction the player moved,
          or it would need to omnisciently know where the player was
          and move in that direction.  This would require that the
          rooms be given geographic coordinates.  As they are now,
          there is nothing to indicate the distance or direction of
          one room from another.  The room data structure is only
          useful for following a path of, say, NORTH through as many
          rooms as possible to construct a view.
        </li>
        <li>
          Have a map with dead ends where the player could be trapped.
        </li>
        <li>
          Handicap the player in certain circumstances.  For instance,
          if the eye gets too close, the player becomes hypnotized
          and cannot move quickly.
        </li>
      </ul>
    </p>

    <h3 id="Random">1.5 Seeding the Random Number Generator</h3>

    <p>
      Both games described always have the same random sequence.  In
      order to get a different random sequence, the random number
      generator must be <em>seeded</em> by
      calling <b><code>srandom()</code></b> with a unique 32-bit argument
      which will determine one of 2<sup>32</sup> different random
      sequences.
    </p>

    <p>
      How can you generate a random seed value?  There are several
      ways, but the easiest way to understand is to use Timer 2.  Turn
      on Timer 2, which has a 32-bit counter, set the smallest
      possible prescaler value, and let the counter run.  Then print a
      message for the user, like:
      <pre>
        Press any key to start.
      </pre>
      When a key press is detected, read the Timer 2 counter value.
      The user will not be able to reliably press a button at exactly
      the right time when the timer is ticking away 48 million times
      per second.  The 32-bit value in TIM2_CNT will be random.
      Pass it as the argument to <b><code>srandom()</code></b>:
      <pre>
        srandom(TIM2->CNT);
      </pre>
      Thereafter, the random sequence will be unpredictable.
    </p>

    <h3 id="Music">1.6 Playing Music</h3>
    <p>
      One of the most common things to add to a game is music.  This
      is easily done with a timer, a wave table, and an analog output
      mechanism (DAC or PWM) like you used in labs 6 and 7.  Since
      PA4 is occupied, you should use the mechanisms you build in lab 7
      to use PWM to synthesize sine waves of various frequencies.
    </p>

    <p>
      Once you have a means of producing a wave of arbitrary frequencies,
      you can produce a song with a list of frequencies and durations.
      You can find the frequency for musical notes by doing a web
      search for "frequency of musical notes".  (e.g., find a web page
      <a href="https://pages.mtu.edu/~suits/notefreqs.html">like this one</a>)
      For instance, a simple "C" scale where each note is played
      for 1000 msec might be represented with an array of structures
      that look like this:
      <pre>
        struct {
            float frequency;
            uint16_t duration;
        } song[] = {
            { 523.25, 1000 }, // C5
            { 587.33, 1000 }, // D5
            { 659.25, 1000 }, // E5
            { 698.46, 1000 }, // F5
            { 783.99, 1000 }, // G5
            { 880.00, 1000 }, // A6
            { 987.77, 1000 }, // B6
            { 1046.50, 1000 }, // C6
        };
      </pre>
      To play music using PWM, use Timer 1 to produce the PWM output.
      Use a second timer to copy wavetable entries into the CCR of
      the appropriate Timer 1 channel.  Use a third timer to step through
      the table of notes and set the step/offset used by the second
      timer.
    </p>

    <h3 id="FAQ">1.7 Frequently Asked Questions</h3>
    <p>
      Answers to other questions will follow below.
    </p>

    <p>
      <b><em>"I need a graphic/music file in a format that can be compiled into my program.  Can you make one for me?"</em></b>
      <br>Yes.  You may ask other students to build game resources for you.
      As long as you're writing your own code for the peripheral interfaces,
      it's totally acceptable to share ancillary files like this &mdash;
      just like it is acceptable for you to reuse the files from the example
      games.
    </p>
    <p>
      <b><em>"How about a two-person game?"</em></b>
      <br>Only if you make it so it can be played and tested by one
      person.  If that means you need to build an AI to play against a
      human, you probably want to choose something else.
    </p>
    <p>
      <b><em>"Do I need to use graphics?"</em></b>
      <br>It would be OK to have a text-based game, (or a number-based
      game such as Sudoku) but you should still use the MSP2202 TFT
      display for this.  Look at the calls for LCD_DrawString() in the
      example code in Lab 8.
    </p>
    <p>
      <b><em>"How many different devices do we need?"</em></b>
      <br>You should use the MSP2202 and at least one other non-SPI
      peripheral.  e.g., 7-segment display, PWM output for audio.
      You can use the OLED LCD, but that's not much more than the
      TFT LCD.
    </p>
    <p>
      <b><em>"Does it have to be a conventional game?"</em></b>
      <br>Not necessarily.  Just make it interactive, and make sure
      that there are multiple simultaneous operations happening.  You
      might consider implementing something like a
      <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot
        set</a> viewer, or display
      <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">
        Conway's Game of Life</a>.
    </p>
    <p>
      <b><em>"Now that the weighting has been changed to bonus credit,
      does that mean I can turn in a trivial game and get 4 bonus
          points?  Yesssss!"</em></b>
      <br>Noooooo.  Bonus point scoring recognizes excellent work without
      <em>penalizing</em> people who aren't able to tolerate much more
      work in this class.  See the suggested scoring rubric below.
    </p>

    <h2 id="Build">2.0 Build a Game</h2>

    <p>
      Your task is to build a game.  It must not be either of the two
      example games described above.  It must be either a significant
      improvement over one of them or something entirely different.
      You can use the mechanisms of the example games as a basis for
      something new.  In particular, you may definitely use the lcd.c
      and lcd.h files to drive the MSP2202 display.  (You can do
      something else if you want to.)
    </p>

    <p>
      Bear in mind that this is not a class in game-making.  It is
      mostly a class about learning to read documentation, but you're
      probably getting tired of reading, and might enjoy actually
      doing something.  The point of game construction is two-fold:
      <ol>
        <li>
          Build something that uses multiple peripherals of the STM32.
          This is the most important quality.
        </li>
        <li>
          Build something that is interesting and <em>playable</em>.
          It does not need to be extremely sophisticated.  The example
          games shown are not very lengthy or complicated.  Yours does
          not need to be either.
        </li>
      </ol>
    </p>

    <h3 id="Requirements">2.1 Requirements</h3>
    <p>
      There are only a few requirements.
      <ul>
        <li>
          Your game must display things on the MSP2202 TFT LCD in
          portrait mode.
        </li>
        <li>
          You must use the "standard game platform" described in
          section 1.1.
        </li>
        <li>
          Your game must be playable.  You know what that means.
          It needs to be minimally usable and obviously act like
          a game.
        </li>
        <li>
          You must use multiple peripherals in a way that appears to
          be simultaneous.  For instance, you might display a
          continually-updated score on the 7-segment displays.  You might
          choose to play a song while the game is in progress.
        </li>
      </ul>
    </p>

    <h3 id="Weight">2.2 Grade Weight</h3>
    <p>
      Originally, the idea was to make this worth the same as a lab.
      There are a lot of students who have had <u>enough</u>.  We get
      it.  There are a lot of staff who feel about the same way.  There
      are also a lot of students whose grade is held down by a practical
      exam score, so a good project wouldn't help them.  What to do?...
    </p>
    <p>
      So this project is going to be "weighted" as bonus credit of
      maximum 4 points.  If you don't turn it in at all, you get zero
      extra points, and it doesn't make your grade go down.  If you're
      struggling with the class, and you can't take any more, you
      don't have to.  On the other hand, if you love this material so
      much that you just can't stop building things and programming
      them, then you deserve to have some recognition for that.
      That's the other reason why this is going to be bonus credit.
      There are already some students who are going way over original
      expectations.  (This always happens.)
    </p>

    <h3 id="Scoring">2.3 Scoring</h3>
    <p>
      The course staff will compile, run, and play your game.  This
      project has been changed to a maximum 4-point bonus applied to
      your normalized weighted percent, so that changes the way we'll
      score it.  Here is the suggested rubric:
      <table class="tbl">
        <tr>
          <th>Score</th>
          <th>Description</th>
        </tr>
        <tr>
          <th>0%</th>
          <th>Turn in nothing.</th>
        </tr>
        <tr>
          <th>0%</th>
          <th>A game that's the same as one of the examples.</th>
        </tr>
        <tr>
          <th>10%</th>
          <th>A playable game that is nearly the same as one of the
          examples, plus continually-updated 7-segment display.</th>
        </tr>
        <tr>
          <th>25%</th>
          <th>A playable game that is nearly the same as one of the
          examples, plus continually-playing music.</th>
        </tr>
        <tr>
          <th>30-90%</th>
          <th>A playable game that is obviously different than the
          examples, with obvious continual update of 7-segment LEDs,
          music, or other game-related simultaneous operations.  Score
          depends on relative complexity.</th>
        </tr>
        <tr>
          <th>100%</th>
          <th>A playable game that has obviously different than the
          examples, with continual simultaneous events, and is clearly
          beyond the minimum necessary implementation.  (Example: a
          pinball game with realistic physics, a side-scroller
          game)</th>
        </tr>
      </table>
      Yes, this might seem a little <em>harsh</em>, but keep in mind
      that this is bonus credit.  25% on this project results in a
      1-point improvement to your final grade &mdash; regardless of
      any NWP limits.  If this were a lab score, you probably wouldn't
      expect that much improvement from a perfect score.
    </p>

    <h3 id="Duedate">2.4 Due Date</h3>
    <p>
      As far as we understand, the latest that anything can be made
      due is the last day of classes: Saturday, December 5.  No one
      should be required to turn in course materials during final exam
      week.  (Although it seems like not everyone follows this rule.)
      The course staff will reserve final exam week as an opportunity
      to follow up with you in case you forget to upload a file or we
      can't get your code to compile.
    </p>

    <p>
      The general rule in the past has been "If Rick is still awake,
      it's still Saturday."  We still don't want compromise your
      preparations for final exams.  Remember that doing nothing will
      not further negatively affect your grade.  Work on this a lot
      if you really enjoy it.
    </p>


    <h2 id="Submission">3 Submit your game files</h2>
    <p>
      Submit your project files with
      <a href="https://engineering.purdue.edu/ece362/submit/?item=proj">
        this link</a>.  <b>Please check to make sure that your files were
      completely uploaded by closing the browser tab, and reopening
      the page.</b>  Your files should all look as they did when you
      uploaded them.
    </p>


    <footer>
      <p>Questions or comments about the course and/or the content of
        these webpages should be sent to
        the <a href="mailto:ece362@ecn.purdue.edu"> Course
        Webmaster</a>.  All the materials on this site are intended
        solely for the use of students enrolled in ECE 362 at the
        Purdue University West Lafayette Campus.  Downloading,
        copying, or reproducing any of the copyrighted materials
        posted on this site (documents or videos) for anything other
        than educational purposes is forbidden.</p>
    </footer>
  </body>
</html>
